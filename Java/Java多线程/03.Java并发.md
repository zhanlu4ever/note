## 1.并发编程的几个概念
### 1.1 同步,异步
* 同步(synchronous):
* 异步(asynchronous):发起异步请求后结果会立即返回,但是请求的结果未必会做完,后台会起一个线程去执行任务,当执行完成后再把结果返回。因此异步调用完不影响下一个操作

### 1.2 并发,并行
* 并发(Concurrency):多个线程交替的进行,
* 并行(Parallelism):多个线程同时进行,齐头并进,

### 1.3 临界区
* 临界区是一种公共资源(共享数据),可以被多个线程使用.但是每一次只能有一个线程使用它,临界区被占用之后其他线程想使用此资源就需要等待.

### 1.4 阻塞(blocking)和非阻塞(non-blocking)
* 在操作系统层面被挂起,阻塞的方式其性能不会很好.每次切换大概需要花费80000个时钟周期

### 1.5 死锁(DeadLock),饥饿(Starvation)和活锁(LiveLock)

### 1.6 并发的级别
* 阻塞
	* 当一个线程进入临界区,其他线程必须等待
* 非阻塞
	* 无障碍
		* 最弱的非阻塞调度,自由出入临界区,无竞争时有限步内完成操作
		* 有竞争时,回滚数据
		* 有死锁的风险,有全部线程进入阻塞的风险
		* 如:读一对数据x,y 当读取完x在去读y时发现x被修改,此时会回滚X的读取数据		
	* 无锁
		* 是无障碍的
		* 并在无障碍的基础上保证一个线程可以胜出		
	* 无等待
		* 是无锁的
		* 在无锁的基础上保证所有的线程必须在有限步内完成
		* 无饥饿
		* 是并行的最高级别

### 1.7 并行的两个重要定律
* Amdahl定律(阿姆达尔定律)
	* 定义了串行系统并行化后的加速比的计算公式和理论上限
	* 加速比: 加速比=优化前系统耗时/优化后系统耗时
	* 优化图示

		![](http://i.imgur.com/mddEetL.png)
		* 加速比=优化前系统耗时/优化后系统耗时=500/400=1.25

	* 增加CPU处理器的数量并不一定能起到有效的作用提高系统内可并行化的模块比重，合理增加并行处理器数量，才能以最小的投入，得到最大的加速比
* Gustafson(古斯塔夫森)
	* 说明处理器,串行比例和加速比之间的关系
	* 只要有足够的并行化,那么加速比和CPU个数成正比
	* 提高程序的可串行化比重和增加CPU

## 2.线程相关的几个函数
### 2.1 Thread.stop()
* 已不推荐使用,非常暴力,会释放所有monitor
* 例:
	* 当前记录,x=1,y=2
	* 准备修改成,x=10,y=20
	* 当修改x=10成功后准备修改y=20时,调用了Thread.stop()
	* 此时由于是释放锁,所以其他线程可以对数据进行读写
	* 其他线程读到x=10,y=2 . 此时就会出现数据不一致的情况

### 2.2 线程中断
* public void Thread.interrupt()				// 中断线程
* public boolean Thread.isInterrupted()			// 判断是否被中断
* public static boolean Thread.interrupted()	// 判断是否被中断，并清除当前中断状态

### 2.3 Thread.sleep(long millis)
* 代码实例:

		@Override
		public void run() {
			while(true){
				if(Thread.currentThread().isInterrupted()){
					break;
				}
				
				try {
					/**
					 * 当线程进入sleep状态时如果此时收到interrupt信号
					 * 则线程会抛出InterruptedException,进而可以进入catch中进行处理
					 * 最后需要重新设置此线程的中断状态
					 */
					Thread.sleep(2000);
				} catch (InterruptedException e) {
	
					// 设置中断状态,抛出异常后会清除中断标志位
					Thread.currentThread().interrupt();
				}
			}
		}