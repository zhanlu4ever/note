## 1.JVM简介
### 1.1 Java与JVM相对独立
* JVM主要定义了二进制class文件和jvm指令集,至于是不是使用java语言编写成的.class文件,jvm不关心

### 1.2 VM指令集
	* 类型转化 	l2i  
	* 出栈入栈操作 	aload  astore
	* 运算 	iadd  isub
	* 流程控制 	ifeq ifne
	* 函数调用 	invokevirtual invokeinterface  invokespecial  invokestatic 

## 2.JVM启动流程
### 2.1 流程图
![](http://i.imgur.com/QNZIZAw.png)

## 3.JVM内部结构
![](http://i.imgur.com/SMY657y.png)

### 3.1 PC寄存器
* 每个线程拥有一个PC寄存器
* 在线程创建时创建
* 指向下一条指令的地址
* 执行本地方法时,PC的值为undefined

### 3.2 方法区
* 保存装载的类信息
	* 类型的常量池
	* 字段,方法信息
	* 方法字节码

	* JDK6时,String等常量信息置于方法
	* JDK7时,已移到了堆
* 通常和永久区(Perm)关联在一起,保存一些相对静止和相对稳定的数据

### 3.3 堆
* 应用系统对象保存在Java堆中
* 所有线程共享Java堆
* 对分代算法的GC而言,堆也是分代的
* GC的主要工作区间

	![](http://i.imgur.com/T32jhFR.png)

### 3.4 栈
* 线程私有
* 栈由一系列栈帧组成
* 帧保存一个方法的局部变量,操作数栈,常量池指针
* 每一次方法调用创建一个帧,并压栈

* 局部变量表
	* 包含参数和局部变量
	* 事例代码

			public class StackDemo {
				public static int statisFun(int i, long l, float f, Object o, byte b) {
					return 0;
				}
			
				public int normalFun(char c, short s, boolean b) {
					return 0;
				}
			}

		* statisFun 表

			![](http://i.imgur.com/zbLKTYv.png)
		* normalFun 表

			![](http://i.imgur.com/ug1TT1v.png)
	* 局部变量表每一个相当于一个槽,32位大小,int正好存放,如果是long类型就会占两个槽
	* 对象是一个引用,是一个指针
	* 实例方法局部变量表的第一个槽位是this

* 方法调用一次就产生一个帧,压栈,当方法结束后,帧出栈
* 操作数栈
	* Java没有寄存器,所有参数传递使用操作数栈.
	* 事例代码

			public static int add(int a, int b) {
				int c = 0;
				c = a + b;
				return c;
			}

		* 反编译代码如下
		
			![](http://i.imgur.com/E1QojQI.png)
		
		* 局部变量表和操作数栈的变化事例

			![](http://i.imgur.com/cOXF4po.png)
* 栈上分配
	* 可以避免内存泄漏
	* 小对象(几十bytes),在没有逃逸的情况下,可以直接在栈上分配
	* 直接分配在栈上可以自动回收,减轻GC压力
	* 大对象或者逃逸对象无法在栈上分配,只在一个线程中使用,其他线程公用的不能在此分配

	* 实例代码

			public class StackDemo {

				public static void alloc() {
					byte[] b = new byte[2];
					b[0] = 1;
				}
			
				public static void main(String[] args) {
					long start = System.currentTimeMillis();
			
					for (int index = 0; index < 1000000000; index++) {
						alloc();
					}
			
					long end = System.currentTimeMillis();
					System.out.println(end - start);
				}
			}

		* 配置运行参数,使用栈分配
			>-server -Xmx10m -Xms10m
						
			>-XX:+DoEscapeAnalysis -XX:+PrintGC
			* 结果8毫秒			
		* 配置运行参数,不使用栈分配
			>-server -Xmx10m -Xms10m
						
			>-XX:-DoEscapeAnalysis -XX:+PrintGC		
			* 结果,不断gc来释放内存,且结果为14517		

### 3.5 堆,栈,方法区之间的交互
* 事例图

	![](http://i.imgur.com/3zuvhty.png)		
	![](http://i.imgur.com/2NtNvgx.png)

## 4.Java内存模型,JMM
### 4.1 内存模型
* 每一个线程有一个工作内存和主存独立
* 工作内存存放主存中变量的值得拷贝

	![](http://i.imgur.com/2Q7ngqu.png)
	![](http://i.imgur.com/h8ZGd8a.png)
* 当数据从主内存复制到工作内存存储时,必须出现两个动作
	* 第一,由主内存执行的读(read)操作
	* 第二,由工作内存执行相应的load操作
* 当数据从工作内存拷贝到主内存时,出现的两个动作
	* 第一,由工作内存执行的存储操作
	* 第二,由主内存执行的相应的写(write)操作
* 每一个操作都是原子的,即执行期间不会被中断
* 对于普通变量,一个线程中更新的值,不能马上反应在其他变量中.若需要在其他线程中立即可见,需要使用volatile关键字
* volatile关键字的语义:当线程A需要使用一个变量时,另外一个线程B一直对这个变量进行更新,此时A线程需要对这个变量一直监听,这时使用volatile可强制数据刷新到主内存
### 4.2 可见性
* 可见性:一个线程修改了变量,其他线程可以立即知道
* 保证可见性的方法
	* volatile
	* synchronized(unlock之前,写变量值回主存)
	* final(一旦初始化完成,其他线程就可见)

### 4.3 有序性
* 在本线程内,操作都是有序的
* 线程外观察,操作都是无序的
	* 指令重排序
	* 主内存同步延时
### 4.4 指令重排序
* 先后两个指令无关时,则指令会被重排序,即可重排
* 插入内存屏障后,屏障前的代码一个优先屏障后的代码执行
* 编译器不考虑多线程之间的语义

* 使用synchronized关键字保证指令的串行

* 指令重排的基本原则
	* 程序顺序原则:一个线程内保证语义的串行性
	* volatile规则:volatile变量的写,先发生于读
	* 锁规则:解锁必然发生在随后的解锁前
	* 传递性:A先于B,B先于C,那么A毕然先于C
	* 线程的start方法先于它的每一个动作
	* 线程的所有操作先于线程的终结(Thread.join())
	* 线程的中断先于被中断的代码
	* 对象的构造函数执行结束先于finalize()方法

### 4.5 解释执行
* 解释执行以解释方式运行字节码
* 解释执行的意思是,读一句执行一句

### 4.6 编译运行(JIT)
* 将字节码编译成机器码
* 直接执行机器码
* 运行时编译
* 编译后性能有数量级的提升

* 编译运行的性能差不多10倍于解释执行

## 5 常用的JVM配置参数
### 5.1 trace跟踪参数
* GC状况的跟踪
	* -verbose:gc	打开GC
	* -XX:+printGC	打开gc日志的开关

	* 简要的GC LOG 解释 
		> [GC 3088K->528K(10240K), 0.0009237 secs]
		* gc ,回收 3088K,gc后使用到的是528k,整个堆大小是10240K,花费的时间0.0009237 secs

	* -XX:+PrintGCDetails		打印GC详细信息,打印结束后才打印堆信息
	* -XX:+PrintGCTimeStamps		打印GC发生的时间戳
	* -Xloggc:log/gc.log			指定GC log的位置,以文件输出
	* -XX:+PrintHeapAtGC			每次GC后都打印堆信息
	* -XX:+TraceClassLoading		监控类的加载
	* -XX:+PrintClassHistogram	运行时在控制台按下ctrl+break,会打印类的信息
		* 分别显示,序号	实例数量		总大小	  类型

			![](http://i.imgur.com/M4ahjrb.png)
			* 第一行,byte数组,总数有890617个,内存大小占470266000

### 5.2 堆分配参数
* -Xmx	-Xms		指定最大堆和最小堆
	* 例, -Xmx20m -Xms5m	   //指定最大20m 最小5m
	* 获取内存信息

			String Xmx = Runtime.getRuntime().maxMemory() / 1024.0 / 1024 + "M";
			String free = Runtime.getRuntime().freeMemory() / 1024.0 / 1024 + "M";
			String total = Runtime.getRuntime().totalMemory() / 1024.0 / 1024 + "M";
	* Java运行时会尽可能维持在最小堆运行
	* -Xmx 和 -Xms 如何分配可保证系统性能更优
	* 比较大的JRE如何瘦身
* -Xmn		设置新生代大小
	* 包括两个Survivor区,s0和s1
* -XX:NewRatio		新生代(eden+2*s) 和老年代(不包含永久区)的比值
	* 例,等于4时表示新生代:老年代=1:4,即年轻代占堆的1/5
* -XX:SurvivorRatio		设置两个Survivor区和eden的比
	* 例,等于8时表示两个Survivor:eden=2:8,即一个Survivor占年轻代的1/10
	* 两个Survivor区,即打印信息中的from和To,也是两个 S0,S1 两个区
* -XX:+HeapDumpOnOutOfMemoryError	OOM时导出堆文件
* -XX+HeapDumpPath	导出OOM的路径
	* 代码实例
		* JVM启动参数: -Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:+HeapDumpPath=D:/xxx.dump

				public static void main(String[] args){
					Vector v = new Vector();
					for(int i=0;i<25;i++){
						v.add(new byte[1*1024*1024]);
					}
				} 
* -XX:OnOutOfMemoryError
	* 在OOM时执行一个脚本
	* 例,-XX:OutOfMemoryError=D:/java/jdk1.7.0_45/bin/printstack.bat %p
		* printstack.bat内编写,D:/java/jdk1.7.0_45/bin/jstack.exe -F %1 > D:/dump.txt
		* 当程序OOM时,在D:/dump.txt 中会生成线程的dump
	* 可以在OOM时,发送邮件或者重启

* 对系统进行调整时若GC次数越多,理论上而言是性能很差的表现
* Survivor 空间过大会导致浪费
* 根据实际情况调整新生代和幸存代的大小
* 官方推荐新生代占堆的3/8
* 幸存代占堆的1/10
* OOM时dump出堆以便排查问题
### 5.3永久区分配参数
	* -XX:PermSize   -XX:MaxPermSize
		* 设置永久区的初始空间和最大空间
		* 表示,一个系统可以容纳多少个类型
	* 有时堆空间即使没使用完也会抛出OOM,有可能是永久区导致的

### 5.4 栈区分配参数
* -Xss
	* 通常只有几百k
	* 决定了函数调用的深度
	* 每个线程都有独立的栈空间
	* 局部变量,参数,分配在栈上

	* 线程数*每个线程的栈空间=系统全部的栈空间
		* 因此每个线程分配的空间不要太大
		* 线程不要开的太多
		
* deep of calling=xxx java.lang.StackOverflowError	栈溢出,函数调用的层次过深
* 减少局部变量的数量,可减少函数调用的空间,可使得调用的函数次数更多些

## 6 GC算法和种类

### 6.1 GC的概念
* Garbage Collection 垃圾收集
	* 回收无用的对象所占据的空间
* GC的对象是堆空间和永久区
* 单独一个线程来完成垃圾收集
### 6.2 垃圾收集算法——引用计数法
* 很老的一个垃圾回收算法
* 通过引用计数来回收垃圾,被引用一次引用计数+1,当引用失效后-1,当引用计数=0时,被回收
* 引用计数法的问题
	* 添加引用和失效引用伴随着加法和减法,影响性能
	* 循环引用处理起来很困难
	
		![](http://i.imgur.com/YZAt81o.png)
		* 第三个图,对象从根对象引用处断开,但是另外三个对象之间循环引用彼此计数都为1,因此此时无法释放
### 6.3 垃圾收集算法——标记清除法
* 标记清除算法是现代垃圾回收算法的思想基础
* 垃圾收集过程:
	* 标记清除算法将垃圾回收分为两个阶段,标记阶段和清除阶段
	* 标记阶段,通过根节点搜索,标记所有从根节点开始的可达对象,未被标记的对象就是未被引用的垃圾对象
	* 清除阶段,清除所有未被标记的对象
### 6.4 垃圾收集算法——标记压缩法
* 适合用于存活对象较多的场合,如老年代
* 垃圾收集过程:
	* 再标记清除算法上做了优化,标记压缩算法也需要从根节点开始,对所有可达对象做一次标记,之后将存活的对象压缩到内存的一端,之后清理边界外的所有空间

* 标记压缩对标记清除的优势在哪里?
### 6.4 垃圾收集算法——复制算法
* 复制算法相对比较高效
* 不适用于存活对象较多的场合,如老年代
* 垃圾收集过程:
	* 将原有的内存空间分为两块,每次只使用其中一块
	* 再垃圾回收时,将正在使用的内存中的存活对象复制到未使用的内存中
	* 然后,清除正在使用的内存中的所有对象,用交换角色的方式来完成垃圾回收

* GC的每一次回收,年龄都会加1,在经过多次GC都没有被回收后且到达一定的年龄时就变为老年对象,被移到老年代

* 存在的问题,空间浪费,复制算法改良

	![](http://i.imgur.com/haVXr1n.png)
	* 说明:
		* 使用老年代作为担保空间XX
		* 划分出来两块小内存空间做复制算法使用,其中一块是空白B,非空为A,以及对象分配空间YY
		* 垃圾回收时将YY中和A中的大对象移到XX
		* 小对象移到B,然后彻底清空YY和A

		* 图中的YY就是eden区,对象产生的地方
		* 图中的A和B就是from和to,也是G0和G1,就是复制算法的两块空间

			![](http://i.imgur.com/AEkoxgp.png)
			* 新生代总空间大小13824k,实际分配为15m
			* eden区为12288k,from和to 分别为1536k
			* 此时的total少了1536k,就是因为复制算法有一半是空的

### 6.5 分代思想
* 依据对象的存活周期进行分类,短命对象归为新生代,长命对象归为老年代
* 根据不同代的特点,选取合适的收集算法
	* 少量对象存活,适合复制算法
	* 大量对象存活,适合标记清理或标记压缩

* 老年代的对象要么是新生代做复制回收时内存不够做担保进来的,多数老年代对象是因为多次GC无法被回收被分配进来的.此时的对象使用复制算法移动起来不划算

### 6.6 垃圾收集算法总结
* 标记清除和标记压缩算法被java 采用,使用再老年代中
* 复制算法被Java 采用,使用再新生代中
* 引用计数算法没有被Java采用

### 6.7 可触及性
* 识别一个垃圾对象,根据可触及性来表示和定义
* 可触及,从根节点可以触及到这个对象
* 可复活,一旦所有引用被释放,就是可复活状态.在finalize()中可能复活该对象
* 不可触及的,在finalize后可能会进入不可触及状态,不可触及的对象不可能复活,可以被回收