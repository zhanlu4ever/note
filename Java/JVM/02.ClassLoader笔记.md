## 深入分析ClassLoader工作机制
> 引自《深入分析JavaWeb技术内幕》第六章

### 1. ClassLoader作用
* ClassLoader,类加载器,负责将Class加载到JVM中
* 检查每个类应该由谁加载,是一种父优先的等级加载机制
* 将Class字节码重新解析成JVM统一要求的对象格式

### 2. CLassLoader类结构
* 类签名
	
		//抽象类,继承此类使用
		public abstract class ClassLoader

* 方法签名

		/*
		 * 将byte字节流解析成JVM能够识别的class对象,使用此方法可以对其他方式实例化对象,如从网络加载
		 * 若直接调用这个方法生成类Class对象,这个类的Class对象还没有resolve, resolve将会在这个对象真正实例化时才进行		
		 */
		protected final Class<?> defineClass(String name, 
			byte[] b, 
			int off, 
			int len, 
			ProtectionDomain protectionDomain)
		  throws ClassFormatError

		/*
		 * 覆盖父类的findClass方法来实现类的加载规则来获得要加载类的字节码
		 */
		protected Class<?> findClass(String name) throws ClassNotFoundException

		/*
		 * 
		 */
		public Class<?> loadClass(String name) throws ClassNotFoundException

		/*
		 * 
		 */
		protected final void resolveClass(Class<?> c)

	* defineClass通常和findClass一起使用
		* 直接覆盖ClassLoader父类的的findClass方法来实现类的加载规则,从而获得要加载类的字节码
		* 调用defineClass方法生成类的Class对象
* 使用ClassLoader,要使用自己的ClassLoader需要继承自URLClassLoader这个子类

### 3. CLassLoader的等级加载机制
* 整个JVM平台提供三层ClassLoader
	* Bootstrap ClassLoader
		* 主要加载JVM自身工作需要的类
		* BootStrap ClassLoader 完全是由JVM自己控制
		* 外界无法访问此类
		* 此加载器不遵循上级加载机制,即此加载器没有父加载器,也没有子加载器
	* ExtClassLoader
		* 此类专门用于加载System.getProperty("java.ext.dirs")目录下的类
	* AppClassLoader
		* 父类是ExtClassLoader
		* 目录System.getProperty("java.class.path")下的类都可以被这个类加载器加载,即常用的classpath
* 自定义类加载器
	* 直接实现抽象类ClassLoader或继承URLClassLoader及其他子类,其父加载器都是AppClassLoader
	* 原因:不管调用哪个父类构造器,创建对象都必须最终调用getSystemClassLoader()作为父类加载器.而getSystemClassLoader()获取到的就是AppClassLoader
	
		![](http://i.imgur.com/9Ey3BCs.png)

	* 注:
		* Bootstrap ClassLoader不属于JVM的类等级层次,因为Bootstrap ClassLoader并未遵循ClassLoader加载规则
		* Bootstrap ClassLoader并没有子类,ExtClassLoader的父类也不是Bootstrap ClassLoader
		* ExtClassLoader并没有父类,在应用中可以提取到的顶层父类ExtClassLoader
		* ExtClassLoader和AppClassLoader都在sun.misc.Launcher中,是Launcher的内部类
	* 类结构层次
		* ExtClassLoader和AppClassLoader继承自URLClassLoader
		* URLClassLoader实现了抽象类ClassLoader
		* 再创建Launcher时会首先创建ExtClassLoader,然后将ExtClassLoader对象作为父加载器创建AppClassLoader
		* 通过Launcher的getClassLoader()方法获取的ClassLoader就是AppClassLoader对象
		* 因此在Java应用中若没有定义其他ClassLoader,除了System.getProperty("java.ext.dirs")目录下的类是由ExtClassLoader加载外,其他类都是由AppClassLoader加载.


### 4. JVM加载class文件到内存的方式
* 隐式加载
	* 不通过在代码里调用ClassLoader来加载需要的类,而是通过JVM来自动加载需要的类到内存方式
	* 例:再类中继承或引用某个类时,JVM在解析当前这个类时发现引用的类不再内存中,那么就会自动将这些类加载到内存中
* 显示加载
	* 再代码中通过调用ClassLoader类来加载一个类
	* loader.getClass().getClassLoader().loadClass("class path")
	* Class.forName("class path")
	* 自定义ClassLoader调用findClass("class path")方法
	
### 5. 如何加载class文件
* 加载过程图示:
	![](http://i.imgur.com/GV2E1if.png)
	* 加载class文件阶段说明:
		* 第一阶段:找到.class文件并将这个文件包含的字节码加载到内存中
		* 第二阶段:分三步
			* 字节码验证
			* Class类数据结构分析
			* 内存分配和最后的符号表的链接
		* 类中静态属性和初始化赋值,以及静态块的执行
* 1).加载字节码到内存
	* findClass()方法是在URLClassLoader中进行实现的.
		![](http://i.imgur.com/HWN9tjH.png)
		* URLClassLoader需要指定一个URL数据才能够创建URLClassLoader对象,即指定ClassLoader默认到哪个目录下去查找class文件
	* URLClassLoader构造函数必须要指定一个URL数据才可以创建URLClassLoader对象,即指定这个ClassLoader默认到哪个目录下去查找class文件
	* URL数组是创建URLClassPath对象的必要条件,即URLClassPath是通过URL的形式来表示ClassPath路径的
	* URLClassPath会根据URL数组中的路径来判断是文件还是jar包,根据不同的路径分别创建FileLoader和JarLoader
	* 当JVM调用findClass时由这几个加载器将class文件的字节码加载到内存中
* 2).验证与解析
	* 字节码验证,类装入器对于类的字节码要做许多检测,以确保格式正确行为正确.
	* 类准备,每个类中定义的字段,方法和实现接口所必需的数据结构
	* 解析,类装入器装入类所用的其他所有类,可以用许多方式引用类,如超类,接口,字段,方法签名,方法中使用的本地变量
* 3).初始化class对象
	* 类中包含的静态初始化器都被执行,这一阶段末尾静态字段被初始化为默认值

### 6. 加载类错误分析
* ClassNotFoundException
	* 解读:JVM加载指定文件的字节码到内存时,找不到文件
	* 出现时机:一般在显示加载类时会报此异常
		* Class的forName("")
		* ClassLoader的loadClass("")方法
		* ClassLoader的findSystemClass()方法
	* 解决方法
		* 检查当前的classpath目录下有没有指定的文件存在
		* 获取classpath,this.getClass().getClassLoader().getResource("").toString()
* NoClassDefFoundError
	* 出错实例:
		* 第一次使用命令执行Java类时可能会遇到
			* 出错,java -cp demo.jar Demo
			* 正确使用,java -cp demo.jar com.cbooy.Demo
	* 出现时机:使用new关键字,属性引用某个类,继承了某个接口或类,或方法的参数中引用了某个类.此时会触发JVM隐式加载这些类时的不存在异常
	* 解决方法
		* 确保每个类的引用都在当前的classpath下
* UnsatisfiedLinkError
	* 出错时机:
		* 启动JVM时,删除某个lib后可能会报此错误
		* 出错代码例子

				public class ClassLoaderDemo{
					public static void main(String[] args) {		
						new ClassLoaderDemo().nativeMethod();
					}
					
					public native void nativeMethod();
					
					static{
						System.loadLibrary("libs");
					}
				}
		* 异常栈信息

				Exception in thread "main" java.lang.UnsatisfiedLinkError: no libs in java.library.path
					at java.lang.ClassLoader.loadLibrary(Unknown Source)
					at java.lang.Runtime.loadLibrary0(Unknown Source)
					at java.lang.System.loadLibrary(Unknown Source)
					at com.cbooy.se.jvm.ClassLoaderDemo.<clinit>(ClassLoaderDemo.java:14)

* ClassCastException
	* 强制类型转换时出此错误
	* JVM类型转换时的检查规则
		* 对于普通对象,对象必须是目标类的实例或目标类的子类的实例,例:如果目标类是接口,会把它当作实现了该接口的一个子类
		* 对于数组类型,目标类必须是数组类型或java.lang.Object,java.lang.Clonable,java.io.Serizable
		* 若不满足以上规则,JVM就会抛出此错误
	* 解决
		* 容器类型中显示地指明这个容器所包含的对象类型,如Map<String,User>
		* 先使用instanceof检查是不是目标类型,后再进行强制类型转换

### 7. 常用ClassLoader分析
* Tomcat ClassLoader

### 8. 自定义ClassLoader
* 在自定义路径下查找自定义的class类文件
* 对要加载的类做特殊处理,如在网络传输中进行加密解密操作,这个过程就需要在自定义ClassLoader中完成
* 定义类的实现机制,如检查类被修改了就重新加载这个类,进而可实现类的热部署

## 深入ClassLoader
> 引自张龙-ClassLoader视频教程

### 1.加载.class到Class对象的过程
* 加载,查找并加载类的二进制数据
	* .class文件的二进制数据读入到内存中,存放在运行时数据区的方法区
	* 在堆区创建一个java.lang.Class对象,用来封装类在方法区内的数据结构

	* 加载.class文件的方式
		* 从本地系统直接加载
		* 通过网络下载,c;ass文件
		* 从zip,jar等归档文件中加载.class文件
		* 从专有数据库中提取.class文件
		* 将java源文件动态编译成.class文件
		
		![](http://i.imgur.com/6AvtMj8.png)

	* 类的加载的最终产品是位于堆区中的Class对象,Class对象封装了类在方法区内的数据结构,并对外提供方法区的数据结构接口

	* JVM规范允许类加载器在预料某个类将要被使用时就预先加载它,如果在预先加载的过程中遇到.class文件缺失或存在错误,类加载器必须在程序首次主动使用该类时才报告错误,LinkageError.
	* 若此类一直没有被程序主动使用,那么类加载器就不会报告错误
* 连接,将已经读入到内存的类二进制数据合并到虚拟机的运行时环境中
	* 验证,确保被加载类的正确性
		* 类文件的结构检查,遵从Java类文件的固定格式
		* 语义检查,符合Java语言规范
		* 字节码验证,
		* 二进制兼容性验证,确保相互引用的类之间的协调一致
			* 如:当在A类方法中调用B类的方法时,若B类的方法不存在(版本不兼容时),抛出NoSuchMethodError错误
	* 准备,为类的静态变量分配内存,并将其初始化为默认值
		* JVM为类的静态变量分配内存,并设置默认初始值
		* 如 private static int a = 4; 为静态变量a分配4个字节的内存空间,并赋予默认值0
	* 解析,把类中的符号引用转换为直接引用
		* 解析阶段,JVM把类的二进制数据中的符号引用替换为直接引用,如

			![](http://i.imgur.com/IfDJR5p.png)

* 初始化,为类的静态变量赋予正确的初始值
	* JVM执行类的初始化语句,为类的静态变量赋予初始值,一般静态初始化有两种途径
		* 静态变量声明处进行初始化
		* 在静态代码块中初始化
	* JVM会按照初始化语句在类文件中的先后顺序来依次执行他们
	* 类的初始化步骤
		* 假如这个类还没被加载和连接,则先进行加和连接
		* 假如类存在直接父类,且此父类还没有被初始化,则先初始化直接父类
		* 假如类中存在初始化语句,则依次执行这些初始化语句

	* 初始化时机
		* JVM初始化一个类时,要求所有父类都已经被初始化,但此规则不适用于接口
		* 初始化一个类,并不会先初始化它所实现的接口
		* 初始化一个接口时,并不会先初始化它的父接口
		
	* 一个父接口并不会因为它的子接口或者实现类的初始化而初始化,只有当程序首次使用特定接口静态变量时,才会导致该接口的初始化
	
			public class LoaderDemo {
				public static void main(String[] args) {
					// 此时虽然主动调用Son1,但是a是由父类继承而来
					// 因此只会对Parent1进行初始化
					System.out.println(Son1.a);
				}
			}
			
			class Parent1{
				static int a = 2;
				static{
					System.out.println("Parent1");
				}
			}
			
			class Son1 extends Parent1{
				static{
					System.out.println("Son1");
				}
			}

	* 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时,才可以算作是对类或接口的主动使用
	* 调用ClassLoader类的loadClass方法加载一个类,并不是对类的主动使用,不会导致类的初始化
### 2.主动使用
* Java程序对类的使用方式分两种
	* 主动使用
	* 被动使用
* 所有Java虚拟机实现必须再每个类或接口被Java程序首次主动使用时才初始化
* 主动使用的六种情况,非以下六种情况外均不会导致类的初始化
	* 创建类的实例
	* 访问某个类或接口的静态变量,或者对该静态变量赋值
	* 调用类的静态方法
	* 反射,Class.forName("xxx.xxx")
	* 初始化一个类的子类
	* Java虚拟机启动时标明为启动的类,如 Java MainTest

### 3.实例代码
	
	//位置1和位置2的切换结果不同
	//位置1时虽然构造方法依然会初始化,但是初始化时类还没对属性a和b分配内存空间
	//因此++操作虽然进行了但是实际结果并未起作用
	public class LoaderDemo2 {
	
		private static LoaderDemo2 instance = new LoaderDemo2(); // 位置1
	
		private static int a = 3;
		
		private static int b = 0;
		
		// private static LoaderDemo2 instance = new LoaderDemo2(); // 位置2
		
		public LoaderDemo2() {
			System.out.println("LoaderDemo2 start");
			a++;
			b++;
		}
		
		public static void main(String[] args) {
			System.out.println(LoaderDemo2.b);
			System.out.println(LoaderDemo2.a);
		}
	}